#!/usr/bin/env python3

"""servic6: a pretty wrapper around s6/s6-rc's utilities"""

__version__ = '0.1.0'
__author__ = 'Mihail Georgiev'
__email__ = 'misho88@gmail.com'
__copyright__ = 'Copyright 2020, Mihail Georgiev'
__license__ = 'GNU GPLv3'

import argparse
import argcomplete
from pathlib import Path

path = Path(__file__)
app = path.name

bundle_commands = ('add', 'delete')
service_commands = ('start', 'stop', 'restart')
misc_commands = ('list', 'log', 'rebuild', 'help')

descriptions = {
    'add': 'add services to a bundle',
    'delete': 'delete services from a bundle',
    'start': 'start services',
    'stop': 'stop services',
    'restart': 'stop services and start them again',
    'log': 'view the logs for a service',
    'list': 'show information about bundles and services',
    'rebuild': 'rebuild the database (Artix specific)',
    'help': 'show documentation on s6 components',
}

parser = argparse.ArgumentParser(prog=app, description='Frontend to s6-rc')
subparsers = parser.add_subparsers(dest='command', required=True,
    help='top-level command')
for command in bundle_commands:
    subparser = subparsers.add_parser(command,
        help=descriptions.get(command, 'bundle command'))
    subparser.add_argument('--bundle', '-b', default='default',
        help='the bundle to operate on')
    subparser.add_argument('services', nargs='+',
        help='the service(s) to modify the bundle with')
for command in service_commands:
    subparser = subparsers.add_parser(command,
        help=descriptions.get(command, 'service command'))
    subparser.add_argument('services', nargs='+',
        help='the service(s) to operate on')
for command in misc_commands:
    subparser = subparsers.add_parser(command,
        help=descriptions.get(command, 'miscellaneous command'))
    subparser.add_argument('items', nargs='*',
        help='services or bundles; blank to show all logs (NOTE: the default '
        'pager is less, where :n and :p switch between buffers for viewing '
        'multiple logs)')
parser.add_argument('--pager', '-p',
    help='override the pager (e.g., less); same as setting PAGER=whatever')
argcomplete.autocomplete(parser)
args = parser.parse_args()

from os import environ
from subprocess import run, CalledProcessError
from shlex import split, join
from natsort import natsorted, ns
from blessed import Terminal

DOC_DIR = environ.get('SERVICE6_DOC_DIR', '/usr/share/doc/service6')
PAGER = environ.get('PAGER', 'less ++G --quit-if-one-screen')

terminal = Terminal()

SYMBOLS = {
    'active': terminal.bright_green('✔ '),
    'dead': terminal.bright_black('✘ '),
    'unknown': terminal.bright_red('❓'),
    'neutral': terminal.bright_red('  '),
    'good': terminal.bright_green('✔ '),
    'bad': terminal.bright_red('✘ '),
}


def hsorted(seq):
    return natsorted(seq, alg=ns.IGNORECASE)


def sh(cmd, capture_output=True, check=True, echo=False):
    if echo:
        pcmd = cmd if isinstance(cmd, str) else join(cmd)
        print(terminal.bold_yellow('>>>'), terminal.bold(pcmd))
    if isinstance(cmd, str):
        cmd = split(cmd)
    return run(cmd, capture_output=capture_output, check=check)


def sh_stdout(cmd):
    return sh(cmd).stdout.decode().rstrip()


def sh_list(cmd):
    return hsorted(sh_stdout(cmd).splitlines())


def sh_set(cmd):
    return set(sh_stdout(cmd).splitlines())


def leader_cell(text, width, position, shape):
    i, j = position
    m, n = shape
    if i == 0:
        tlen = terminal.length(text)
        output = '─' * width
        if m > 1 and width > 2:
            output = output[:-2] + '┬─'
        output = text + output[tlen:]
    else:
        output = ' ' * width
        if width > 2:
            output = output[:-2] + ('├─' if i < m - 1 else '╰─')
    return output


def data_cell(text, width, position, shape):
    tlen = terminal.length(text)
    pad = terminal.bright_black('─' * (width - tlen - 2))
    return f'{pad}{text}'


def tabulate(results):
    leader_col_width = max(
        terminal.length(key)
        for key in results.keys()
    ) + 2
    data_col_width = max(
        terminal.length(item)
        for items in results.values()
        for item in items
    ) + 2
    n_cols = (terminal.width - leader_col_width) // data_col_width
    for key, items in results.items():
        n_rows, rem = divmod(len(items), n_cols)
        n_rows += rem != 0
        shape = n_rows, n_cols
        for row, i in enumerate(range(0, len(items), n_cols)):
            print(leader_cell(key, leader_col_width, (row, 0), shape), end='')
            for col, item in enumerate(items[i:i + n_cols], start=1):
                print(data_cell(item, data_col_width, (row, col), shape), end='')
            print()


def do_list(args):
    all_bundles = sh_set("s6-rc-db list bundles")
    all_services = sh_set("s6-rc-db list services")
    active_services = sh_set("s6-rc -a list")

    list_items = set(args.items)
    list_bundles = all_bundles & list_items if list_items else all_bundles
    list_services = all_services & list_items if list_items else all_services
    list_unknown = list_items - (list_bundles | list_services)

    bundles = {
        bundle: sh_set(f"s6-rc-bundle-update list {bundle}")
        for bundle in list_bundles
    }
    claimed_services = {
        service
        for bundle_services in bundles.values()
        for service in bundle_services
    }

    result_items = hsorted(bundles.items()) + [
        ('', list_services - claimed_services),
        ('unknown', list_unknown),
    ]
    results = {}
    for bundle, bundle_services in result_items:
        if not bundle_services:
            continue
        color = {
            '': lambda text: text,
            'unknown': terminal.bold_red,
        }.get(bundle, terminal.bold_yellow)

        subbundles = {
            subbundle
            for subbundle, subbundle_services in bundles.items()
            if subbundle_services < bundle_services
        }
        subbundles = {
            a
            for a in subbundles
            if not any(bundles[a] < bundles[b] for b in subbundles)
        }
        results[color(bundle)] = [
            f'{color(subbundle)}   '
            for subbundle in hsorted(subbundles)
        ]
        printed_services = bundle_services.copy()
        for subbundle in subbundles:
            printed_services -= bundles[subbundle]

        if bundle == 'unknown':
            def get_symbol(service):
                return SYMBOLS['unknown']
        else:
            def get_symbol(service):
                active = service in active_services
                return SYMBOLS['active' if active else 'dead']

        results[color(bundle)] += [
            f"{service} {get_symbol(service)}"
            for service in hsorted(printed_services)
        ]
    tabulate(results)


def do_start(args):
    services = " ".join(args.services)
    sh(f's6-rc -u -v 2 change {services}', capture_output=False, echo=True)


def do_stop(args):
    services = " ".join(args.services)
    sh(f's6-rc -d -v 2 change {services}', capture_output=False, echo=True)


def do_restart(args):
    do_stop(args)
    do_start(args)


def do_add(args):
    services = " ".join(args.services)
    bundle = args.bundle
    bundles = sh_list("s6-rc-db list bundles")
    if bundle in bundles:
        sh(f's6-rc-bundle-update add {bundle} "{services}"', capture_output=False, echo=True)
    else:
        sh(f's6-rc-bundle add {bundle} {services}', capture_output=False, echo=True)


def do_delete(args):
    bundles = sh_list("s6-rc-db list bundles")

    services = []
    for service in args.services:
        if service in bundles:
            services += sh_list(f"s6-rc-bundle-update list {service}")
        else:
            services.append(service)
    services_str = " ".join(services)
    bundle = args.bundle
    sh(f's6-rc-bundle-update delete {bundle} "{services_str}"', capture_output=False, echo=True)


def do_help(args):
    all_doc_names = [ p.name for p in Path(DOC_DIR).glob('*') ]
    if not all_doc_names:
        print(terminal.bold_red(f"docs not found in {DOC_DIR}"))
        return
    if not args.items:
        tabulate({ terminal.bold_green('Available'): all_doc_names })
        print(terminal.bold_yellow(
            f"You can access {app}'s help with '{app} --help/-h'.\n"
            f"You can access each command's help with '{app} command --help/-h'."
        ))
        return
    items = []
    baditems = []
    for item in args.items:
        if item in all_doc_names:
            items.append(item)
        elif not item.startswith('s6-') and f's6-{item}' in all_doc_names:
            items.append(f's6-{item}')
        elif item not in baditems:
            baditems.append(item)
            if not item.startswith('s6-'):
                baditems.append(f's6-{item}')
    if baditems:
        available = [
            f'{item} {SYMBOLS["good" if item in items else "neutral"]}'
            for item in all_doc_names
        ]
        baditems = [ f'{item} {SYMBOLS["bad"]}' for item in baditems ]
        tabulate({
            terminal.bold_green('Available'): available,
            terminal.bold_red('Unavailable'): baditems,
        })
    else:
        doc_files = [ Path(DOC_DIR) / item for item in items ]
        sh(split(PAGER) + hsorted(str(f) for f in doc_files), capture_output=False, echo=True)


def do_rebuild(args):
    sh('/usr/share/libalpm/scripts/s6-rc-db-update-hook', capture_output=False, echo=True)


def do_log(args):
    var_log = Path('/var/log')
    logs = set(args.items)
    names = {
        path.name
        for path in var_log.iterdir()
        if path.is_dir() and path.owner() == 's6log'
    }
    if logs - names:
        tabulate({
            terminal.bold_green('Available'): hsorted(names),
            terminal.bold_red('Unavailable'): hsorted(logs - names),
        })
    else:
        log_files = {
            var_log / name / 'current'
            for name in logs or names
        }
        sh(split(PAGER) + hsorted(str(f) for f in log_files), capture_output=False, echo=True)


bundle_commands = {
    'add': do_add,
    'delete': do_delete,
}

service_commands = {
    'start': do_start,
    'stop': do_stop,
    'restart': do_restart,
}

misc_commands = {
    'list': do_list,
    'rebuild': do_rebuild,
    'log': do_log,
    'help': do_help,
}

commands = dict(
    **bundle_commands,
    **service_commands,
    **misc_commands,
)

if args.pager is not None:
    environ['PAGER'] = args.pager

try:
    commands[args.command](args)
except CalledProcessError as e:
    print(terminal.bright_red(str(e)))
    if e.stdout:
        print(e.stdout.decode())
    if e.stderr:
        print(terminal.red(e.stderr.decode()))
