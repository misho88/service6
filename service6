#!/usr/bin/env python3

"""servic6: a pretty wrapper around s6/s6-rc's utilities"""

__version__ = '0.1.0'
__author__ = 'Mihail Georgiev'
__email__ = 'misho88@gmail.com'
__copyright__ = 'Copyright 2020, Mihail Georgiev'
__license__ = 'GNU GPLv3'

from argparse import ArgumentParser
from argcomplete import autocomplete
from pathlib import Path
from os import environ
from sys import stderr, exit
from subprocess import run, CalledProcessError, Popen, PIPE
from shlex import split, join
from contextlib import ExitStack


DOC_DIR = environ.get('SERVICE6_DOC_DIR', '/usr/share/doc/service6')
DOC_NAMES = tuple(p.name for p in Path(DOC_DIR).iterdir())
PAGER = environ.get('PAGER', 'less ++G --quit-if-one-screen')
LOG_PATH = Path(environ.get('SERVICE6_LOG_PATH', '/var/log'))
LOG_OWNER = environ.get('SERVICE6_LOG_OWNER', 's6log')

PRIVILEGE_ESCALATION = environ.get('SERVICE6_PRIVILEGE_ESCALATION', 'never')
if PRIVILEGE_ESCALATION not in ('never', 'list', 'always'):
    print(
        'SERVICE6_PRIVILEGE_ESCALATION must be never, list or always, not '
        f'{PRIVILEGE_ESCALATION}',
        file=stderr,
    )
    exit(1)
if PRIVILEGE_ESCALATION == 'never':
    SUDO = LIST_SUDO = ()
else:
    sudo_candidates = 'sudo', 'doas'
    with ExitStack() as stack:
        procs = (
            Popen(( 'which', exe ), stdout=PIPE, stderr=PIPE)
            for exe in sudo_candidates
        )
        sprocs = ( stack.enter_context(proc) for proc in procs )
        for i, proc in enumerate(sprocs):
            if proc.wait() == 0:
                LIST_SUDO = sudo_candidates[i], '-n'
                break
        else:
            LIST_SUDO = ()
    SUDO = LIST_SUDO if PRIVILEGE_ESCALATION == 'always' else ()

CMD = {
    'list bundles': LIST_SUDO + ('s6-rc-db', 'list', 'bundles'),
    'list services': LIST_SUDO + ('s6-rc-db', 'list', 'services'),
    'list active': LIST_SUDO + ('s6-rc', '-a', 'list'),
    'list in bundle': LIST_SUDO + ('s6-rc-bundle-update', 'list')
}


def get_set(cmd):
    return set(run(
        cmd,
        capture_output=True,
        check=True,
    ).stdout.decode().splitlines())


path = Path(__file__)
app = path.name

bundle_commands = 'add', 'delete'
service_commands = 'start', 'stop', 'restart'
misc_commands = 'list', 'log', 'rebuild', 'help'

descriptions = {
    'add': 'add services to a bundle',
    'delete': 'delete services from a bundle',
    'start': 'start services',
    'stop': 'stop services',
    'restart': 'stop services and start them again',
    'log': 'view the logs for a service',
    'list': 'show information about bundles and services',
    'rebuild': 'rebuild the database (Artix specific)',
    'help': 'show documentation on s6 components',
}


def null_completer(**kwargs):
    return ()


def path_completer(**kwargs):
    path = environ['PATH'].split(':')
    return [
        exe.name
        for dir in path
        for exe in Path(dir).iterdir()
        if exe.lstat().st_mode & 0o100400  # regular file, executable
    ]


completers = {
    'bundle': lambda **_: get_set(CMD['list bundles']),
    'add': lambda **_: get_set(CMD['list services']),
    'delete': lambda **_: get_set(CMD['list services']),
    'start': lambda **_: get_set(CMD['list services']) - get_set(CMD['list active']),
    'stop': lambda **_: get_set(CMD['list active']),
    'restart': lambda **_: get_set(CMD['list services']),
    'log': lambda **_: [ d.name for d in LOG_PATH.iterdir() if d.is_dir() and d.owner() == LOG_OWNER ],
    'list': lambda **_: get_set(CMD['list bundles']) | get_set(CMD['list services']),
    'help': lambda **_: DOC_NAMES,
    'pager': path_completer,
}

parser = ArgumentParser(prog=app, description='Frontend to s6-rc')
subparsers = parser.add_subparsers(dest='command', required=True,
    help='top-level command')

for command in bundle_commands:
    subparser = subparsers.add_parser(
        command,
        help=descriptions.get(command, 'bundle command'),
    )
    subparser.add_argument(
        '--bundle', '-b', default='default',
        help='the bundle to operate on',
    ).completer = completers.get('bundle', null_completer)
    subparser.add_argument(
        'services', nargs='+',
        help='the service(s) to modify the bundle with',
    ).completer = completers.get(command, null_completer)

for command in service_commands:
    subparser = subparsers.add_parser(
        command,
        help=descriptions.get(command, 'service command'),
    )
    subparser.add_argument(
        'services', nargs='+',
        help='the service(s) to operate on',
    ).completer = completers.get(command, null_completer)

for command in misc_commands:
    subparser = subparsers.add_parser(
        command,
        help=descriptions.get(command, 'miscellaneous command')
    )
    subparser.add_argument(
        'items', nargs='*',
        help='services or bundles',
    ).completer = completers.get(command, null_completer)

parser.add_argument(
    '--pager', '-p',
    help='override the pager (e.g., less); same as setting PAGER environment '
         'variable (NOTE: use :n and :p to switch buffers in less when '
         'viewing multiple items)',
).completer = completers['pager']

autocomplete(parser)
args = parser.parse_args()

from natsort import natsorted, ns
from blessed import Terminal

terminal = Terminal()

SYMBOLS = {
    'active': terminal.bright_green('✔ '),
    'dead': terminal.bright_black('✘ '),
    'unknown': terminal.bright_red('❓'),
    'neutral': terminal.bright_red('  '),
    'good': terminal.bright_green('✔ '),
    'bad': terminal.bright_red('✘ '),
}


def hsorted(seq):
    return natsorted(seq, alg=ns.IGNORECASE)


def sh(cmd, capture_output=True, check=True, echo=False):
    if echo:
        pcmd = cmd if isinstance(cmd, str) else join(cmd)
        print(terminal.bold_yellow('>>>'), terminal.bold(pcmd))
    if isinstance(cmd, str):
        cmd = split(cmd)
    return run(cmd, capture_output=capture_output, check=check)


def sh_stdout(cmd):
    return sh(cmd).stdout.decode().rstrip()


def sh_list(cmd):
    return hsorted(sh_stdout(cmd).splitlines())


def parallel(argvs):
    with ExitStack() as stack:
        procs = [
            stack.enter_context(Popen(argv, stdout=PIPE, stderr=PIPE))
            for argv in argvs
        ]
        outputs = [ proc.stdout.read() for proc in procs ]
        for i, proc in enumerate(procs):
            returncode = proc.wait()
            if returncode:
                raise CalledProcessError(returncode, proc.args, outputs[i], proc.stderr.read())
    return outputs


def leader_cell(text, width, position, shape):
    i, j = position
    m, n = shape
    if i == 0:
        tlen = terminal.length(text)
        output = '─' * width
        if m > 1 and width > 2:
            output = output[:-2] + '┬─'
        output = text + output[tlen:]
    else:
        output = ' ' * width
        if width > 2:
            output = output[:-2] + ('├─' if i < m - 1 else '╰─')
    return output


def data_cell(text, width, position, shape):
    tlen = terminal.length(text)
    pad = terminal.bright_black('─' * (width - tlen - 2))
    return f'{pad}{text}'


def tabulate(results):
    leader_col_width = max(
        terminal.length(key)
        for key in results.keys()
    ) + 2
    data_col_width = max(
        terminal.length(item)
        for items in results.values()
        for item in items
    ) + 3
    n_cols = (terminal.width - leader_col_width) // data_col_width
    for key, items in results.items():
        n_rows, rem = divmod(len(items), n_cols)
        n_rows += rem != 0
        shape = n_rows, n_cols
        for row, i in enumerate(range(0, len(items), n_cols)):
            print(leader_cell(key, leader_col_width, (row, 0), shape), end='')
            for col, item in enumerate(items[i:i + n_cols], start=1):
                print(data_cell(item, data_col_width, (row, col), shape), end='')
            print()


def do_list(args):
    outputs = parallel(CMD[t] for t in ('list bundles', 'list services', 'list active'))
    all_bundles, all_services, active_services = (
        set(output.decode().splitlines())
        for output in outputs
    )

    list_items = set(args.items)
    list_bundles = all_bundles & list_items if list_items else all_bundles
    list_services = all_services & list_items if list_items else all_services
    list_unknown = list_items - (list_bundles | list_services)

    outputs = parallel(CMD['list in bundle'] + (bundle,) for bundle in list_bundles)
    bundles = {
        bundle: set(output.decode().splitlines())
        for bundle, output in zip(list_bundles, outputs)
    }

    claimed_services = {
        service
        for bundle_services in bundles.values()
        for service in bundle_services
    }

    result_items = hsorted(bundles.items()) + [
        ('', list_services - claimed_services),
        ('unknown', list_unknown),
    ]
    results = {}
    for bundle, bundle_services in result_items:
        if not bundle_services:
            continue
        color = {
            '': lambda text: text,
            'unknown': terminal.bold_red,
        }.get(bundle, terminal.bold_yellow)

        subbundles = {
            subbundle
            for subbundle, subbundle_services in bundles.items()
            if subbundle_services < bundle_services
        }
        subbundles = {
            a
            for a in subbundles
            if not any(bundles[a] < bundles[b] for b in subbundles)
        }
        results[color(bundle)] = [
            f'{color(subbundle)}   '
            for subbundle in hsorted(subbundles)
        ]
        printed_services = bundle_services.copy()
        for subbundle in subbundles:
            printed_services -= bundles[subbundle]

        if bundle == 'unknown':
            def get_symbol(service):
                return SYMBOLS['unknown']
        else:
            def get_symbol(service):
                active = service in active_services
                return SYMBOLS['active' if active else 'dead']

        results[color(bundle)] += [
            f"{service} {get_symbol(service)}"
            for service in hsorted(printed_services)
        ]
    tabulate(results)


def do_start(args):
    services = " ".join(args.services)
    sh(f's6-rc -u -v 2 change {services}', capture_output=False, echo=True)


def do_stop(args):
    services = " ".join(args.services)
    sh(f's6-rc -d -v 2 change {services}', capture_output=False, echo=True)


def do_restart(args):
    do_stop(args)
    do_start(args)


def do_add(args):
    services = " ".join(args.services)
    bundle = args.bundle
    bundles = sh_list("s6-rc-db list bundles")
    if bundle in bundles:
        sh(f's6-rc-bundle-update add {bundle} "{services}"', capture_output=False, echo=True)
    else:
        sh(f's6-rc-bundle add {bundle} {services}', capture_output=False, echo=True)


def do_delete(args):
    bundles = sh_list("s6-rc-db list bundles")

    services = []
    for service in args.services:
        if service in bundles:
            services += sh_list(f"s6-rc-bundle-update list {service}")
        else:
            services.append(service)
    services_str = " ".join(services)
    bundle = args.bundle
    sh(f's6-rc-bundle-update delete {bundle} "{services_str}"', capture_output=False, echo=True)


def do_help(args):
    if not DOC_NAMES:
        print(terminal.bold_red(f"docs not found in {DOC_DIR}"))
        return
    if not args.items:
        tabulate({ terminal.bold_green('Available'): DOC_NAMES })
        print(terminal.bold_yellow(
            f"You can access {app}'s help with '{app} --help/-h'.\n"
            f"You can access each command's help with '{app} command --help/-h'."
        ))
        return
    items = []
    baditems = []
    for item in args.items:
        if item in DOC_NAMES:
            items.append(item)
        elif not item.startswith('s6-') and f's6-{item}' in DOC_NAMES:
            items.append(f's6-{item}')
        elif item not in baditems:
            baditems.append(item)
            if not item.startswith('s6-'):
                baditems.append(f's6-{item}')
    if baditems:
        available = [
            f'{item} {SYMBOLS["good" if item in items else "neutral"]}'
            for item in DOC_NAMES
        ]
        baditems = [ f'{item} {SYMBOLS["bad"]}' for item in baditems ]
        tabulate({
            terminal.bold_green('Available'): available,
            terminal.bold_red('Unavailable'): baditems,
        })
    else:
        doc_files = [ Path(DOC_DIR) / item for item in items ]
        sh(split(PAGER) + hsorted(str(f) for f in doc_files), capture_output=False, echo=True)


def do_rebuild(args):
    sh('/usr/share/libalpm/scripts/s6-rc-db-update-hook', capture_output=False, echo=True)


def do_log(args):
    var_log = Path('/var/log')
    logs = set(args.items)
    names = {
        path.name
        for path in var_log.iterdir()
        if path.is_dir() and path.owner() == 's6log'
    }
    if not logs or logs - names:
        tabulate({
            terminal.bold_green('Available'): hsorted(names),
            terminal.bold_red('Unavailable'): hsorted(logs - names),
        })
    else:
        log_files = {
            var_log / name / 'current'
            for name in logs or names
        }
        sh(split(PAGER) + hsorted(str(f) for f in log_files), capture_output=False, echo=True)


bundle_commands = {
    'add': do_add,
    'delete': do_delete,
}

service_commands = {
    'start': do_start,
    'stop': do_stop,
    'restart': do_restart,
}

misc_commands = {
    'list': do_list,
    'rebuild': do_rebuild,
    'log': do_log,
    'help': do_help,
}

commands = dict(
    **bundle_commands,
    **service_commands,
    **misc_commands,
)

if args.pager is not None:
    environ['PAGER'] = args.pager

try:
    commands[args.command](args)
except CalledProcessError as e:
    print(terminal.bright_red(str(e)))
    if e.stdout:
        print(e.stdout.decode())
    if e.stderr:
        print(terminal.red(e.stderr.decode()))
